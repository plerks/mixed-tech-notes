参考：
* [【C++】头文件中写类的实现出现函数重复定义的问题](https://blog.csdn.net/weixin_41838721/article/details/123678812)
* [【浅析】把实现放在头文件中的函数模板，为什么没有发生重定义错误](https://blog.csdn.net/friendbkf/article/details/45420379)
* [C++模板的定义是否只能放在头文件中？](https://blog.csdn.net/imred/article/details/80261632)
* [C++11模板隐式实例化、显式实例化声明、定义（简单易懂）](https://blog.csdn.net/Jxianxu/article/details/124359007)

## 模板类、模板函数直接在头文件中实现
一般情况下，头文件中只需要进行声明即可，而具体的实现放在.cpp中，然后编译成目标文件后进行链接。

但是对于模板（模板函数、模板类），例如std::make_pair, std::move, std::vector，其实现都是直接放在头文件中的，为什么？

因为模板的代码是需要在编译过程中，根据实际的调用实例化的。

假设add.h中有一个模板函数add()，且main.cpp include了add.h，

如果模板的实现在add.cpp中，那么如果main.cpp中调用了模板，那么编译main.cpp生成目标文件时，由于没有具体实现是没有进行实例化的。同时，编译add.cpp时，模板函数的使用在其它文件中，编译器编译时都是以单个文件为一个编译单元进行编译的，编译add.cpp时根本不知道有哪些具体的调用，所以也不会实例化模板。

也就是说，实现放在add.cpp中，是无法触发模板的实例化的。

所以，模板的实现必须直接写在头文件中，这样在调用模板时编译器才能根据实际调用的类型实例化模板。

如果硬要把模板实现放在.cpp中，也不是不可以，得在模板实现的地方指明要实例化哪些类型，需要这样：

在add.h中声明模板以供其它文件include：
```cpp
template<typename T>
T add(T& a, T& b);
```

在add.cpp中直接定义模板的实例化：
```cpp
#include<add.h>

template<typename T>
T add(T& a, T& b) {
    return a + b;
}

template int add(int& a, int& b);
```
但是这种方式实际没什么用途，每在其它文件中有一种模板使用就得在add.cpp中添加一行，如果add.cpp实际不是源代码，是第三方的库文件，则根本不可行。

## 模板实现在头文件中，为什么不会导致重定义？
如果多个源代码文件include了模板的头文件并以相同的类型调用了模板之后，实例化的模板应该是相同的，那么链接时为什么没有报错重定义？

因为编译器实例化多个相同的模板时，最终只会有一份实现。（多个实例相同，只保留一份就行了，除了减少空间使用还有防止重定义的作用，不然得给相同的实例加独特后缀进行区分）

PS: 内联函数由于会展开在实际调用的地方，所以内联函数直接把实现写在头文件里也不会有重定义的问题。但是如果一个内联函数进行了修改，所有使用该内联函数的目标文件库文件都要重新编译，不然用的是旧函数。